# RDB grammar
%strict

%token ID CHAR NUM
%token NEWLINE

%{
	use Carp;
	our $VERSION = '0.01';
	my %s;

	use constant S_ERR_ATTRTYPE => 10;
%}

%%

start
	: prog
	;

prog
	: (relation tuple* NEWLINE*)+ 
	;

tuple
	: constants NEWLINE
	;

constants 
	: constant (',' constant)*
	;

relation
	: '@' ID '(' attributes ')' ':' identifiers NEWLINE
	;

attributes
	: attribute (',' attribute)* 
	;

attribute
	: ID '/' typename { my ($id, $type) = ($_[1], $_[3]); _SemanticError($_[0], S_ERR_ATTRTYPE, $id, $type) if ((defined $s{@$id[0]}) and (@{$s{@$id[0]}}[0] ne @$type[0])); $s{@$id[0]} = $type; }
	;

identifiers
	: ID (',' ID { $_[2]; })* { push(@{$_[2]}, $_[1]); return $_[2]; }
	;
	
constant 
	: CHAR
	| NUM
	;

typename 
	: 'char'
	| 'numeric'
	;

%%

my $lineno = 1;

sub _SemanticError {
	my $parser = shift;
	my $errType = shift;
	
	my ($err, $lineno);
	if ($errType == S_ERR_ATTRTYPE) {
		my ($id, $type) = @_;
		$lineno = @$id[1];
		$err = "Type of previous declared attribute '@$id[0]' (@{$s{@$id[0]}}[0]) at line @{$s{@$id[0]}}[1]\ndoesn't match with new declared type (@$type[0])"
	}
	die << "ERRMSG";
Semantic error: $err at line $lineno
ERRMSG
}

sub _Error {
  my $parser = shift;
  my $yydata = $parser->YYData;

    exists $yydata->{ERRMSG}
  and do {
      warn $yydata->{ERRMSG};
      delete $yydata->{ERRMSG};
      return;
  };
  my($token)=$parser->YYCurval;
  my($what)= $token->[0] ? "input: '$token->[0]'" : "end of input";
  my @expected = $parser->YYExpect();
  local $" = ', ';
  warn << "ERRMSG";

Syntax error near $what (lin num $token->[1]). 
Expected one of these terminals: @expected
ERRMSG
}

sub make_lexer {
	my $input = shift;
	my ($beginline, $lineno) = (1, 1);

	return sub {
		my $parser = shift;
		$beginline = $lineno;
		for ($input) {    # contextualize
			m{\G[ \t]*(\#.*)?}gc;

			m{\G(char|numeric)}gc           and return ($1, [$1, $beginline]);
			m{\G([0-9]+(?:\.[0-9]+)?)}gc    and return ('NUM', [$1, $beginline]);
			m{\G([A-Za-z_][A-Za-z0-9_]*)}gc and return ('ID', [$1, $beginline]);
			m{\G((["'])(.*)\2)}gc           and return ('CHAR', [$3, $beginline]);	# Just for Vim syntax highlighting matching the '"
			#m{\G\r}gc                       and return ("\r", ["\r", $beginline]);
			m{\G\n}gc                       and do { $lineno++; return ("NEWLINE", ["\n", $beginline]) };
			m{\G(.)}gc                      and return ($1,    [$1, $beginline]);

			return('',undef);
		}
	}
}

sub Run {
	my ($self) = shift;

	my $input = shift;
use Data::Dumper;
print Dumper("Symbol table" . %s);
	return [%s, $self->YYParse( yylex => make_lexer($input), yyerror => \&_Error )];
}

