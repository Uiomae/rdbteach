# RDB grammar
%strict

%token ID CHAR NUM
%token NEWLINE

%{
	use Carp;
	our $VERSION = '0.01';
	my (%s, %rel);

	use constant S_ERR_ATTRTYPE => 10;
	use constant S_ERR_ATTRNONEXIST => 11;
	use constant S_ERR_RELEXISTS => 12;
%}

%%

start
	: prog
	;

prog
	: (relation tuple* NEWLINE*)+ 
	;

tuple
	: constants NEWLINE
	;

constants 
	: constant (',' constant)*
	;

relation
	: '@' ID '(' attributes ')' ':' identifiers NEWLINE { my $id = _CheckAttrs($_[7]); _SemanticError($_[0], S_ERR_ATTRNONEXIST, $id) if defined $id; _NewRel(@_); }
	;

attributes
	: attribute (',' attribute { $_[2]; })* { unshift(@{$_[2]}, $_[1]); return $_[2]; }
	;

attribute
	: ID '/' typename { my ($id, $type) = ($_[1], $_[3]); _SemanticError($_[0], S_ERR_ATTRTYPE, $id, $type) if ((defined $s{@$id[0]}) and (@{$s{@$id[0]}}[0] ne @$type[0])); $s{@$id[0]} = $type; [@$id[0], @$type[0]]; }
	;

identifiers
	: ID (',' ID { $_[2]; })* { unshift(@{$_[2]}, $_[1]); return $_[2]; }
	;
	
constant 
	: CHAR
	| NUM
	;

typename 
	: 'char'
	| 'numeric'
	;

%%

my $lineno = 1;

sub _NewRel {
	my ($parser, $relName, $attribs, $keys) = ($_[0], $_[2], $_[4], $_[7]);
	_SemanticError($parser, S_ERR_RELEXISTS, $relName) if defined $rel{@$relName[0]};

	$rel{@$relName[0]} = { "tuples" => [], "attribs" => [], "keys" => [], "line" => @$relName[1] };
	use Data::Dumper;
	print Dumper(%rel);
}

sub _CheckAttrs {
	my ($attrs) = shift;

	foreach my $attr (@$attrs) {
		return $attr unless defined $s{@$attr[0]};
	}
	return undef;
}

sub _SemanticError {
	my $parser = shift;
	my $errType = shift;
	
	my ($err, $lineno);
	for ($errType) {
		$_ == S_ERR_ATTRTYPE and do {
			my ($id, $type) = @_;
			$lineno = @$id[1];
			$err = "Type of previous declared attribute '@$id[0]' (@{$s{@$id[0]}}[0]) at line @{$s{@$id[0]}}[1]\ndoesn't match with new declared type (@$type[0])";
		};
		$_ == S_ERR_ATTRNONEXIST and do {
			my ($id) = @_;
			$lineno = @$id[1];
			$err = "Attribute '@$id[0]' doesn't exist";
		};
		$_ == S_ERR_RELEXISTS and do {
			my ($id) = @_;
			$lineno = @$id[1];
			my %temp = %{$rel{@$id[0]}};
			$err = "Relation '@$id[0]' already exists (previously defined at line $temp{line})";
		};
	}
	die << "ERRMSG";
Semantic error: $err at line $lineno
ERRMSG
}

sub _Error {
  my $parser = shift;
  my $yydata = $parser->YYData;

    exists $yydata->{ERRMSG}
  and do {
      warn $yydata->{ERRMSG};
      delete $yydata->{ERRMSG};
      return;
  };
  my($token)=$parser->YYCurval;
  my($what)= $token->[0] ? "input: '$token->[0]'" : "end of input";
  my @expected = $parser->YYExpect();
  local $" = ', ';
  warn << "ERRMSG";

Syntax error near $what (lin num $token->[1]). 
Expected one of these terminals: @expected
ERRMSG
}

sub make_lexer {
	my $input = shift;
	my ($beginline, $lineno) = (1, 1);

	return sub {
		my $parser = shift;
		$beginline = $lineno;
		for ($input) {    # contextualize
			m{\G[ \t]*(\#.*)?}gc;

			m{\G(char|numeric)}gc           and return ($1, [$1, $beginline]);
			m{\G([0-9]+(?:\.[0-9]+)?)}gc    and return ('NUM', [$1, $beginline]);
			m{\G([A-Za-z_][A-Za-z0-9_]*)}gc and return ('ID', [$1, $beginline]);
			m{\G((["'])(.*)\2)}gc           and return ('CHAR', [$3, $beginline]);	# Just for Vim syntax highlighting matching the '"
			#m{\G\r}gc                       and return ("\r", ["\r", $beginline]);
			m{\G\n}gc                       and do { $lineno++; return ("NEWLINE", ["\n", $beginline]) };
			m{\G(.)}gc                      and return ($1,    [$1, $beginline]);

			return('',undef);
		}
	}
}

sub Run {
	my ($self) = shift;

	my $input = shift;
use Data::Dumper;
print Dumper("Symbol table" . %s);
	return [%s, $self->YYParse( yylex => make_lexer($input), yyerror => \&_Error )];
}

